---
title: "Minimum Span Frequency Assignment Problem"
subtitle: "Enfoque Directo frente a Decodificador"
author: "Your Name"
date: "2025-09-08"
output: 
  bookdown::pdf_document2:
    fig_caption: yes
    toc: false    
    extra_dependencies: ["subfig", "amssymb", "amsmath"]
papersize: a4
fontsize: 11pt
geometry:
  - top=1in
  - bottom=1in
  - left=1.5in
  - right=1.5in
params: 
  instances: ["p1", "p2"]
  algorithms: ["decoder1","decoder2"]
  maxevals: 100000
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
```

```{r data-preparation}
library(rjson)

# general parameters
maxevals <- params$maxevals
instances <- params$instances
algorithms <- params$algorithms

# samples a datafile at regular intervals
sampling <- function (rundata, s, maxevals) {
  n = length(rundata$evals)
  numsamples <- floor(maxevals/s)
  mat <- matrix(nrow=numsamples, ncol=2)
  first <- rundata$evals[1] 
  i<-1
  for (j in seq(from = 1, to = numsamples)) {
    ev <- j * s;
    mat[j,1] <- ev
    if (ev < first) {
      mat[j,2] <- NA
    } else {
      while ((i<=n) & (rundata$evals[i] < ev)) {
        i <- i + 1
      }
      if ((i<=n) & (rundata$evals[i] == ev)) {
        k <- i
      }
      else {
        k <- i - 1
      }
      mat[j,2] <- rundata$data[k]
    }
  }
  return (mat)
} 

# standard error of the mean
stderror <- function(x) sd(x)/sqrt(length(x))

# reduces a list of matrices to a single matrix using 
# some aggregation function
statmat <- function(lst, fnc) {        
  n <- length(lst) 	   
  rc <- dim(lst[[1]]) 	   
  ar1 <- array(unlist(lst), c(rc, n)) 
  mat <- apply(ar1, c(1, 2), fnc)
  colnames(mat)=c("evals", "best", "current", "mean")#, "diversity")
  return(mat)
}

# prepares the results of a single island in a format amenable for further
# processing
process_rundata <- function (rundata) {
  s <- 100
  df <- data.frame(evals = rundata$isols$evals,
                   data  = rundata$isols$fitness)
  mat1 <- sampling(df, s, maxevals)
  n <- length(rundata$idata$evals)
df <- data.frame(evals = rundata$idata$evals,
                   data  = rundata$idata$best)
  mat2 <- sampling(df, s, maxevals)
  mat1 <- cbind(mat1, mat2[,2])
  df <- data.frame(evals = rundata$idata$evals,
                   data  = rundata$idata$mean, n)
  mat2 <- sampling(df, s, maxevals)
  mat1 <- cbind(mat1, mat2[,2])
  colnames(mat1) <- c("evals", "current", "best", "mean")
  mat1
}

# processes a batch of data files (one per run)
# computes the mean and standard error of each column
process_runbatch <- function (data) {
  stats <- list()
  numislands <- length(data[[1]]$rundata)
  numruns <- length(data)
  for (i in seq(1, numruns)) {
    # compute the global EA state at each moment
    runmat <- process_rundata(data[[i]]$rundata[[1]])
    if (i == 1) {
      resbestall <- data.frame("evals" = runmat[,"evals"])
    }
    if (numislands>1) {
      for (j in seq(2, numislands)) {
        mat <- process_rundata(data[[i]]$rundata[[j]])
        runmat[,"current"] <- pmax(runmat[,"current"], mat[,"current"])
        runmat[,"best"] <- pmax(runmat[,"best"], mat[,"best"])
        runmat[,"mean"] <- runmat[,"mean"] + mat[,"mean"]
        #runmat[,"diversity"] <- runmat[,"diversity"] + mat[,"diversity"]
      }
      runmat[,"mean"] <- runmat[,"mean"]/numislands
      #runmat[,"diversity"] <- runmat[,"diversity"]/numislands
    }
    stats[[i]] <- runmat
    resbestall[sprintf("run%d",i)] <- runmat[,"best"]
  }
  resmean <- as.data.frame(statmat(stats, mean))
  resse <- as.data.frame(statmat(stats, stderror))
  return (list("mean"=resmean, "se"=resse, "all" = resbestall))
}

get_solutions <- function (data) {
  numruns <- length(data)
  numvar <- length(data[[1]]$rundata[[1]]$isols$genome[[1]])
  table_solutions <- data.frame(matrix(ncol=numvar+2, nrow=numruns))
  colnames(table_solutions) <- c("evals", "fitness", paste("V", 1:numvar, sep=""))
  
  for (i in 1:numruns) {
    rowi <- max(which(data[[i]]$rundata[[1]]$isols$evals < maxevals))
    table_solutions[i, "evals"] <- data[[i]]$rundata[[1]]$isols$evals[rowi]
    table_solutions[i, "fitness"] <- data[[i]]$rundata[[1]]$isols$fitness[rowi]
    for (j in seq(1, numvar)) {
      table_solutions[i, j+2] <- data[[i]]$rundata[[1]]$isols$genome[rowi][[1]][j]
    }
  }
  return(table_solutions)
}



num_algorithms <- length(algorithms)
num_instances <- length(instances)
data_list <- list()
i <- 1
for (instance in instances) {
  for (alg in algorithms) {
    json_data <- fromJSON(file = paste(alg, "-stats-", instance, ".json", sep=""))
    data_list[[i]] <- list("rundata" = process_runbatch(json_data),
                           "sols" = get_solutions(json_data))
    i <- i + 1
  }
}

data_processed <- matrix(data = data_list, ncol = num_instances,
                         dimnames = list(algorithms, instances))
rm(list=c("data_list", "json_data"))
```

# Introducción


# Resultados


```{r fitness-evol, fig.cap = "Evolución de fitness promediada sobre todas las ejecuciones", fig.subcap=instances, out.width="33%"}

library(ggplot2)
library(scales)

maxy <- list()
miny <- list()
for (instance in instances) {
  may <- 0 
  miy <- -Inf
  for (alg in algorithms) {
    val <- data_processed[[alg, instance]]$rundata$mean$best + 
           data_processed[[alg, instance]]$rundata$se$best
    val <- val[is.finite(val)]
    if (max(val) > may) {
      may <- max(val)
    }
    val <- data_processed[[alg, instance]]$rundata$mean$best - 
           data_processed[[alg, instance]]$rundata$se$best
    val <- val[is.finite(val) & val >= 0]
    if (min(val) > miy) {
      miy <- min(val)
    }
  }
  maxy <- append(maxy, may)
  miny <- append(miny, miy)
}
names(maxy) <- instances
names(miny) <- instances

for (instance in instances) {
  alg <- algorithms[1]
  numrows <- dim(data_processed[[alg, instance]][["rundata"]]$mean)[1]
  df <- data.frame(matrix(ncol=4, nrow=num_algorithms*numrows))
  colnames(df) <- c("evals", "best", "se", "alg")
  i <- 0
  for (alg in algorithms) {
    rundata <- data_processed[[alg, instance]][["rundata"]]
    df[["evals"]][(i*numrows+1):((i+1)*numrows)] <- rundata[["mean"]]$evals
    df[["best"]][(i*numrows+1):((i+1)*numrows)] <- rundata[["mean"]]$best
    df[["se"]][(i*numrows+1):((i+1)*numrows)] <- rundata[["se"]]$best
    df[["alg"]][(i*numrows+1):((i+1)*numrows)] <- alg
    i <- i + 1;
  }
    
  show(ggplot(data=df, aes(x=evals, color = alg, group = alg)) + 
      geom_line(aes(y=best)) +
      geom_ribbon(aes(ymin=best-se, ymax=best+se), fill='black', alpha=0.2) +
      coord_cartesian(ylim = c(miny[[instance]], maxy[[instance]])) +
      xlab("number of evaluations") +
      ylab("fitness") +
      ggtitle(instance) +
      theme_bw() + 
      labs(color = "") + 
      theme(aspect.ratio=1, legend.position = c(.65, .50),
            legend.justification = c(0, 1), 
            legend.box.margin=margin(c(5,5,5,5)),
            legend.background = element_rect(fill='transparent')))

}

rm (list = c("rundata", "miny", "maxy", "df"))
```



```{r fitness}

getPval <- function(instance, alg1, alg2) {
  v1 <- data_processed[[alg1, instance]][["sols"]]$fitness
  v2 <- data_processed[[alg2, instance]][["sols"]]$fitness
  s <- wilcox.test(v1, v2, alternative = "two.sided")
  if (is.na(s$p.value)) {
    s$p.value <- 1
  }
  
  return(s$p.value)
}

getSymbol <- function (alg, instance) {
  if (alg == bestalg[instance])
    return ("$\\star$")
  pval <- table_significance[instance, alg]
  if (pval>0.05)
    return ("$\\phantom{\\bullet}$")
  else 
    return ("$\\bullet$")

}

table_significance <- data.frame(matrix(nrow=num_instances, ncol=num_algorithms))
colnames(table_significance) <- algorithms
rownames(table_significance) <- instances

bestalg <- data.frame(matrix(nrow=1, ncol=num_instances))
colnames(bestalg) <- instances

for (instance in instances) {
  best <- -Inf
  for (alg in algorithms) {
    val <- mean(data_processed[[alg, instance]][["sols"]]$fitness)
    if (val > best) {
      best <- val
      bestalg[instance] <- alg
    }
  }
  for (alg in algorithms) {
    table_significance[instance, alg] <- getPval(instance, alg, bestalg[[instance]])
  }
}

library(kableExtra)

#number of digits
prec <- 3

table_fitness <- data.frame(matrix(nrow=num_instances, ncol=4*num_algorithms))
colnames(table_fitness) <- apply(expand.grid(c("best", "median", "mean", "stat"), algorithms), 
                                 1, paste, collapse = ".")
rownames(table_fitness) <- instances
first_header <- c(1, rep(4, num_algorithms))
names(first_header) <- c(" ", algorithms)
second_header <- rep(1, 1 + num_algorithms * 4)
names(second_header) <- c("instancia", rep(c("$x^*$", "$\\tilde{x}$", 
                                            "$\\bar{x} \\pm \\sigma_{\\bar{x}}$", " "), num_algorithms))
for (alg in algorithms) {
  for (instance in instances) {
    data_solutions <- data_processed[[alg, instance]][["sols"]]
    table_fitness[instance, paste("best", alg, sep=".")] <- 
      round(max(data_solutions[, "fitness"]), prec)
    table_fitness[instance, paste("median", alg, sep=".")] <- 
      round(median(data_solutions[, "fitness"]),prec)
    table_fitness[instance, paste("mean", alg, sep=".")] <- paste(round(mean(data_solutions[, "fitness"]), prec), "$\\pm$", round(stderror(data_solutions[, "fitness"]), prec))
    table_fitness[instance, paste("stat", alg, sep=".")] <- getSymbol(alg, instance)
  }
}

rm (data_solutions)



table_fitness %>%
  kbl(escape = FALSE,
      booktabs = T, 
      caption = "Resultados de los algoritmos. Cada columna muestra el mejor valor encontrado ($x^*$), la mediana ($\\tilde{x}$), la media ($\\bar{x}$) y el error estándard de la media ($\\sigma_{\\bar{x}}$). Una estrella $\\star$ marca al mejor algoritmo en cada instancia, y un símbolo $\\bullet$ indica que los resultados son estadísticamente significativos con $\\alpha=0.05$",
      col.names=names(second_header)) %>%
kable_styling(full_width = F, latex_options="scale_down") %>%
add_header_above(first_header) #c(" "=1, "ea" = 3)

```
