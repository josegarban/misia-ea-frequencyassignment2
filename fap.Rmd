---
title: "Minimum Span Frequency Assignment Problem"
subtitle: "Enfoque Directo frente a Decodificador"
author: "Your Name"
date: "2025-09-08"
output: 
  bookdown::pdf_document2:
    fig_caption: yes
    toc: false    
    extra_dependencies: ["subfig", "amssymb", "amsmath"]
papersize: a4
fontsize: 11pt
geometry:
  - top=1in
  - bottom=1in
  - left=1.5in
  - right=1.5in
params: 
  instances: ["p1", "p2", "p3", "p5", "p6"]
  algorithms: ["decoderfae","decoderfaf"]
  maxevals: 100000
bibliography: references.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
```

```{r data-preparation}
library(rjson)

# general parameters
maxevals <- params$maxevals
instances <- params$instances
algorithms <- params$algorithms

# samples a datafile at regular intervals
sampling <- function (rundata, s, maxevals) {
  n = length(rundata$evals)
  numsamples <- floor(maxevals/s)
  mat <- matrix(nrow=numsamples, ncol=2)
  first <- rundata$evals[1] 
  i<-1
  for (j in seq(from = 1, to = numsamples)) {
    ev <- j * s;
    mat[j,1] <- ev
    if (ev < first) {
      mat[j,2] <- NA
    } else {
      while ((i<=n) & (rundata$evals[i] < ev)) {
        i <- i + 1
      }
      if ((i<=n) & (rundata$evals[i] == ev)) {
        k <- i
      }
      else {
        k <- i - 1
      }
      mat[j,2] <- rundata$data[k]
    }
  }
  return (mat)
} 

# standard error of the mean
stderror <- function(x) sd(x)/sqrt(length(x))

# reduces a list of matrices to a single matrix using 
# some aggregation function
statmat <- function(lst, fnc) {        
  n <- length(lst) 	   
  rc <- dim(lst[[1]]) 	   
  ar1 <- array(unlist(lst), c(rc, n)) 
  mat <- apply(ar1, c(1, 2), fnc)
  colnames(mat)=c("evals", "best", "current", "mean")#, "diversity")
  return(mat)
}

# prepares the results of a single island in a format amenable for further
# processing
process_rundata <- function (rundata) {
  s <- 100
  df <- data.frame(evals = rundata$isols$evals,
                   data  = rundata$isols$fitness)
  mat1 <- sampling(df, s, maxevals)
  n <- length(rundata$idata$evals)
df <- data.frame(evals = rundata$idata$evals,
                   data  = rundata$idata$best)
  mat2 <- sampling(df, s, maxevals)
  mat1 <- cbind(mat1, mat2[,2])
  df <- data.frame(evals = rundata$idata$evals,
                   data  = rundata$idata$mean, n)
  mat2 <- sampling(df, s, maxevals)
  mat1 <- cbind(mat1, mat2[,2])
  colnames(mat1) <- c("evals", "current", "best", "mean")
  mat1
}

# processes a batch of data files (one per run)
# computes the mean and standard error of each column
process_runbatch <- function (data) {
  stats <- list()
  numislands <- length(data[[1]]$rundata)
  numruns <- length(data)
  for (i in seq(1, numruns)) {
    # compute the global EA state at each moment
    runmat <- process_rundata(data[[i]]$rundata[[1]])
    if (i == 1) {
      resbestall <- data.frame("evals" = runmat[,"evals"])
    }
    if (numislands>1) {
      for (j in seq(2, numislands)) {
        mat <- process_rundata(data[[i]]$rundata[[j]])
        runmat[,"current"] <- pmax(runmat[,"current"], mat[,"current"])
        runmat[,"best"] <- pmax(runmat[,"best"], mat[,"best"])
        runmat[,"mean"] <- runmat[,"mean"] + mat[,"mean"]
        #runmat[,"diversity"] <- runmat[,"diversity"] + mat[,"diversity"]
      }
      runmat[,"mean"] <- runmat[,"mean"]/numislands
      #runmat[,"diversity"] <- runmat[,"diversity"]/numislands
    }
    stats[[i]] <- runmat
    resbestall[sprintf("run%d",i)] <- runmat[,"best"]
  }
  resmean <- as.data.frame(statmat(stats, mean))
  resse <- as.data.frame(statmat(stats, stderror))
  return (list("mean"=resmean, "se"=resse, "all" = resbestall))
}

get_solutions <- function (data) {
  numruns <- length(data)
  numvar <- length(data[[1]]$rundata[[1]]$isols$genome[[1]])
  table_solutions <- data.frame(matrix(ncol=numvar+2, nrow=numruns))
  colnames(table_solutions) <- c("evals", "fitness", paste("V", 1:numvar, sep=""))
  
  for (i in 1:numruns) {
    rowi <- max(which(data[[i]]$rundata[[1]]$isols$evals < maxevals))
    table_solutions[i, "evals"] <- data[[i]]$rundata[[1]]$isols$evals[rowi]
    table_solutions[i, "fitness"] <- data[[i]]$rundata[[1]]$isols$fitness[rowi]
    for (j in seq(1, numvar)) {
      table_solutions[i, j+2] <- data[[i]]$rundata[[1]]$isols$genome[rowi][[1]][j]
    }
  }
  return(table_solutions)
}



num_algorithms <- length(algorithms)
num_instances <- length(instances)
data_list <- list()
i <- 1
for (instance in instances) {
  for (alg in algorithms) {
    json_data <- fromJSON(file = paste(alg, "-stats-", instance, ".json", sep=""))
    data_list[[i]] <- list("rundata" = process_runbatch(json_data),
                           "sols" = get_solutions(json_data))
    i <- i + 1
  }
}

data_processed <- matrix(data = data_list, ncol = num_instances,
                         dimnames = list(algorithms, instances))
rm(list=c("data_list", "json_data"))
```

# Introducción

El problema de asignación de frecuencias (FAP) es de considerable importancia para diversos servicios militares y civiles como las redes de telefonía móvil, que proveen cobertura a áreas urbanas y rurales alrededor del mundo, lo cual requiere una asignación eficiente y efectiva del espectro radioeléctrico a cada proveedor (@valenzuela1998permutation). La industria de telecomunicaciones requiere permisos por parte del Estado donde sus servicios se desarrollen, y esto implica tanto competencia con otras compañías como la adaptación a los espectros permitidos por los teléfonos móviles según el estándar que corresponda. El volumen de señales que se intercambian entre los dispositivos de cada usuario y las antenas debe transmitirse reduciendo la interferencia por parte de otros dispositivos tanto de la misma compañía que provee el servicio como por parte de otras compañías. La asignación eficiente debe asimismo tomar en cuenta la topología local que comprende obstáculos como edificios y montañas. Por otra parte, la ubicación de las antenas puede requerir pagos a los propietarios de las fincas donde se coloquen o permisos a las autoridades correspondientes. La necesidad de mantener la lealtad de los usuarios con un servicio de buena calidad, la complejidad de seleccionar los puntos dónde colocar las antenas y la envergadura de la infraestructura requerida repercuten en costes que hace que el FAP sea de considerable valor económico.

Existen diversas formulaciones del problema y técnicas de búsqueda que incluyen las siguientes características comunes (@aardal2007models):

\begin{enumerate}
\item Deben asignarse frecuencias a un conjunto de antenas para que la transmisión de datos sea posible, dentro de un conjunto de frecuencias que puede diferir según conexiones.
\item Las frecuencias asignadas a dos conexiones pueden resultar en interferencia bajo las siguientes condiciones: (a) las dos frecuencias están cerca en la banda (b) las conexiones deben estar geográficamente próximas.
\end{enumerate}

De todas las variantes del problema FAP que existen, la que se analizará es la \textit{Minimum Span Frequency Assignation Problem} (MS-FAP). En este problema se busca minimizar la amplitud (\textit{span}) de la asignación de frecuencias, lo que es la diferencia entre la frecuencia más alta y las más baja utilizadas. 

\clearpage 
La formulación a ser empleada es la siguiente: 

Dadas $n$ emisoras $\mathcal{E} = \{ e_{1}, \ldots, e_{n} \}$, donde $e_{i} = (id_{i}, (x_{i}, y_{i}, z_{i}), d_{i})$, y restricciones de interferencia especificadas por $\delta : \mathbb{N} \to \mathbb{R}$, encontrar una asignación de frecuencias $\Psi = \{\psi_{1}, \ldots, \psi_{n}\} \in (2^{\mathbb{N}})^{n}$ tal que:

\begin{enumerate}
  \item $\forall i \in \{1, \ldots, n\} : \ |\psi_{i}| = d_{i}$

  \item $\forall i,j \in \{1, \ldots, n\}, \ \forall f_{1} \in \psi_{i}, \ \forall f_{2} \in \psi_{2}:$ 
  $(i \neq j) \ \lor \ (f_{1} \neq f_{2}) \ \Rightarrow \ dist(e_{i}, e_{j}) \geq \delta(|f_{1} - f_{2}|)$
  
  \item Se minimiza el rango $r(\Psi)$ de frecuencias empleadas:
  $r(\Psi) = \max_{1 \leq i \leq n} \left( \max_{f \in \psi_{i}} f \right) - \min_{1 \leq i \leq n} \left( \min_{f \in \psi_{i}} f \right)$
\end{enumerate}


El FAP es \textit{NP-hard} (@valenzuela1998permutation) y se ha resuelto mediante diferentes algoritmos, que incluyen metaheurísticas como algoritmos voraces, búsqueda local, búsqueda tabú y algoritmos evolutivos, entre otros @luna2011optimization. 

Las instancias a utilizarse en el problema son las instancias de Filadelfia, que son 21 hexágonos representando una red celular simplificada sobre dicha ciudad estadounidense, cada una de las cuales requiere un número de frecuencias  (@aardal2007models). Todas las instancias tienen la misma cantidad de emisores, pero varían las siguientes características (a) demanda por celda y (b) distancia mínima entre emisores para poder usar una frecuencia adyacente en una cantidad determinada de unidades de frecuencia. La demanda aumenta progresivamente con las instancias.

\begin{table}[ht]
\centering
\caption{Descripción de las instancias del problema de asignación de frecuencias (FAP).}
\label{tab:fap-instances}
\begin{tabular}{lcccc}
\hline
\textbf{Instancia} & \textbf{Emisores} & \textbf{$\sum_{i} d_{i}$} & \textbf{$min(d_{i}$)} & \textbf{$max(d_{i})$} \\
\hline
p1 & 21 & 481 & 8  & 77 \\
p2 & 21 & 481 & 8  & 77 \\
p3 & 21 & 470 & 5  & 45 \\
p4 & 21 & 470 & 5  & 45 \\
p5 & 21 & 420 & 20 & 20 \\
p6 & 21 & 420 & 20 & 20 \\
\hline
\end{tabular}
\end{table}

# Resultados


# Referencias

```{r fitness-evol, fig.cap = "Evoluci\\'on de fitness promediada sobre todas las ejecuciones", fig.subcap=instances, out.width="50%"}

library(ggplot2)
library(scales)

maxy <- list()
miny <- list()
for (instance in instances) {
  may <- 0 
  miy <- -Inf
  for (alg in algorithms) {
    val <- data_processed[[alg, instance]]$rundata$mean$best + 
           data_processed[[alg, instance]]$rundata$se$best
    val <- val[is.finite(val)]
    if (max(val) > may) {
      may <- max(val)
    }
    val <- data_processed[[alg, instance]]$rundata$mean$best - 
           data_processed[[alg, instance]]$rundata$se$best
    val <- val[is.finite(val) & val >= 0]
    if (min(val) > miy) {
      miy <- min(val)
    }
  }
  maxy <- append(maxy, may)
  miny <- append(miny, miy)
}
names(maxy) <- instances
names(miny) <- instances

for (instance in instances) {
  alg <- algorithms[1]
  numrows <- dim(data_processed[[alg, instance]][["rundata"]]$mean)[1]
  df <- data.frame(matrix(ncol=4, nrow=num_algorithms*numrows))
  colnames(df) <- c("evals", "best", "se", "alg")
  i <- 0
  for (alg in algorithms) {
    rundata <- data_processed[[alg, instance]][["rundata"]]
    df[["evals"]][(i*numrows+1):((i+1)*numrows)] <- rundata[["mean"]]$evals
    df[["best"]][(i*numrows+1):((i+1)*numrows)] <- rundata[["mean"]]$best
    df[["se"]][(i*numrows+1):((i+1)*numrows)] <- rundata[["se"]]$best
    df[["alg"]][(i*numrows+1):((i+1)*numrows)] <- alg
    i <- i + 1;
  }
    
  show(ggplot(data=df, aes(x=evals, color = alg, group = alg)) + 
      geom_line(aes(y=best)) +
      geom_ribbon(aes(ymin=best-se, ymax=best+se), fill='black', alpha=0.2) +
      coord_cartesian(ylim = c(miny[[instance]], maxy[[instance]])) +
      xlab("number of evaluations") +
      ylab("fitness") +
      ggtitle(instance) +
      theme_bw() + 
      labs(color = "") + 
      theme(aspect.ratio=1, legend.position = c(.65, .50),
            legend.justification = c(0, 1), 
            legend.box.margin=margin(c(5,5,5,5)),
            legend.background = element_rect(fill='transparent')))

}
rm (list = c("rundata", "miny", "maxy", "df"))
```




