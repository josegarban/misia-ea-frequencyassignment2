knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
library(rjson)
# general parameters
maxevals <- params$maxevals
instances <- params$instances
algorithms <- params$algorithms
# samples a datafile at regular intervals
sampling <- function (rundata, s, maxevals) {
n = length(rundata$evals)
numsamples <- floor(maxevals/s)
mat <- matrix(nrow=numsamples, ncol=2)
first <- rundata$evals[1]
i<-1
for (j in seq(from = 1, to = numsamples)) {
ev <- j * s;
mat[j,1] <- ev
if (ev < first) {
mat[j,2] <- NA
} else {
while ((i<=n) & (rundata$evals[i] < ev)) {
i <- i + 1
}
if ((i<=n) & (rundata$evals[i] == ev)) {
k <- i
}
else {
k <- i - 1
}
mat[j,2] <- rundata$data[k]
}
}
return (mat)
}
# standard error of the mean
stderror <- function(x) sd(x)/sqrt(length(x))
# reduces a list of matrices to a single matrix using
# some aggregation function
statmat <- function(lst, fnc) {
n <- length(lst)
rc <- dim(lst[[1]])
ar1 <- array(unlist(lst), c(rc, n))
mat <- apply(ar1, c(1, 2), fnc)
colnames(mat)=c("evals", "best", "current", "mean", "diversity")
return(mat)
}
# prepares the results of a single island in a format amenable for further
# processing
process_rundata <- function (rundata) {
s <- 100
df <- data.frame("evals" = rundata$isols$evals, "data" = rundata$isols$fitness)
mat1 <- sampling(df, s, maxevals)
df <- data.frame("evals" = rundata$idata$evals, "data" = rundata$idata$best)
mat2 <- sampling(df, s, maxevals)
mat1 <- cbind(mat1, mat2[,2])
df <- data.frame("evals" = rundata$idata$evals, "data" = rundata$idata$mean)
mat2 <- sampling(df, s, maxevals)
mat1 <- cbind(mat1, mat2[,2])
df <- data.frame("evals" = rundata$idata$evals, "data" = rundata$idata$diversity)
mat2 <- sampling(df, s, maxevals)
mat1 <- cbind(mat1, mat2[,2])
colnames(mat1) <- c("evals", "best", "current", "mean", "diversity")
return (mat1)
}
# processes a batch of data files (one per run)
# computes the mean and standard error of each column
process_runbatch <- function (data) {
stats <- list()
numislands <- length(data[[1]]$rundata)
numruns <- length(data)
for (i in seq(1, numruns)) {
# compute the global EA state at each moment
runmat <- process_rundata(data[[i]]$rundata[[1]])
if (i == 1) {
resbestall <- data.frame("evals" = runmat[,"evals"])
}
if (numislands>1) {
for (j in seq(2, numislands)) {
mat <- process_rundata(data[[i]]$rundata[[j]])
runmat[,"current"] <- pmax(runmat[,"current"], mat[,"current"])
runmat[,"best"] <- pmax(runmat[,"best"], mat[,"best"])
runmat[,"mean"] <- runmat[,"mean"] + mat[,"mean"]
runmat[,"diversity"] <- runmat[,"diversity"] + mat[,"diversity"]
}
runmat[,"mean"] <- runmat[,"mean"]/numislands
runmat[,"diversity"] <- runmat[,"diversity"]/numislands
}
stats[[i]] <- runmat
resbestall[sprintf("run%d",i)] <- runmat[,"best"]
}
resmean <- as.data.frame(statmat(stats, mean))
resse <- as.data.frame(statmat(stats, stderror))
return (list("mean"=resmean, "se"=resse, "all" = resbestall))
}
get_solutions <- function (data) {
numruns <- length(data)
numvar <- length(data[[1]]$rundata[[1]]$isols$genome[[1]])
table_solutions <- data.frame(matrix(ncol=numvar+2, nrow=numruns))
colnames(table_solutions) <- c("evals", "fitness", paste("V", 1:numvar, sep=""))
for (i in 1:numruns) {
rowi <- max(which(data[[i]]$rundata[[1]]$isols$evals < maxevals))
table_solutions[i, "evals"] <- data[[i]]$rundata[[1]]$isols$evals[rowi]
table_solutions[i, "fitness"] <- data[[i]]$rundata[[1]]$isols$fitness[rowi]
for (j in seq(1, numvar)) {
table_solutions[i, j+2] <- data[[i]]$rundata[[1]]$isols$genome[rowi][[1]][j]
}
}
return(table_solutions)
}
num_algorithms <- length(algorithms)
num_instances <- length(instances)
data_list <- list()
i <- 1
for (instance in instances) {
for (alg in algorithms) {
json_data <- fromJSON(file = paste(alg, "-stats-", instance, ".json", sep=""))
data_list[[i]] <- list("rundata" = process_runbatch(json_data),
"sols" = get_solutions(json_data))
i <- i + 1
}
}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
library(rjson)
# general parameters
maxevals <- params$maxevals
instances <- params$instances
algorithms <- params$algorithms
# samples a datafile at regular intervals
sampling <- function (rundata, s, maxevals) {
n = length(rundata$evals)
numsamples <- floor(maxevals/s)
mat <- matrix(nrow=numsamples, ncol=2)
first <- rundata$evals[1]
i<-1
for (j in seq(from = 1, to = numsamples)) {
ev <- j * s;
mat[j,1] <- ev
if (ev < first) {
mat[j,2] <- NA
} else {
while ((i<=n) & (rundata$evals[i] < ev)) {
i <- i + 1
}
if ((i<=n) & (rundata$evals[i] == ev)) {
k <- i
}
else {
k <- i - 1
}
mat[j,2] <- rundata$data[k]
}
}
return (mat)
}
# standard error of the mean
stderror <- function(x) sd(x)/sqrt(length(x))
# reduces a list of matrices to a single matrix using
# some aggregation function
statmat <- function(lst, fnc) {
n <- length(lst)
rc <- dim(lst[[1]])
ar1 <- array(unlist(lst), c(rc, n))
mat <- apply(ar1, c(1, 2), fnc)
colnames(mat)=c("evals", "best", "current", "mean", "diversity")
return(mat)
}
# prepares the results of a single island in a format amenable for further
# processing
process_rundata <- function (rundata) {
s <- 100
df <- data.frame("evals" = rundata$isols$evals, "data" = rundata$isols$fitness)
mat1 <- sampling(df, s, maxevals)
df <- data.frame("evals" = rundata$idata$evals, "data" = rundata$idata$best)
mat2 <- sampling(df, s, maxevals)
mat1 <- cbind(mat1, mat2[,2])
df <- data.frame("evals" = rundata$idata$evals, "data" = rundata$idata$mean)
mat2 <- sampling(df, s, maxevals)
mat1 <- cbind(mat1, mat2[,2])
df <- data.frame("evals" = rundata$idata$evals, "data" = rundata$idata$diversity)
mat2 <- sampling(df, s, maxevals)
mat1 <- cbind(mat1, mat2[,2])
colnames(mat1) <- c("evals", "best", "current", "mean", "diversity")
return (mat1)
}
# processes a batch of data files (one per run)
# computes the mean and standard error of each column
process_runbatch <- function (data) {
stats <- list()
numislands <- length(data[[1]]$rundata)
numruns <- length(data)
for (i in seq(1, numruns)) {
# compute the global EA state at each moment
runmat <- process_rundata(data[[i]]$rundata[[1]])
if (i == 1) {
resbestall <- data.frame("evals" = runmat[,"evals"])
}
if (numislands>1) {
for (j in seq(2, numislands)) {
mat <- process_rundata(data[[i]]$rundata[[j]])
runmat[,"current"] <- pmax(runmat[,"current"], mat[,"current"])
runmat[,"best"] <- pmax(runmat[,"best"], mat[,"best"])
runmat[,"mean"] <- runmat[,"mean"] + mat[,"mean"]
runmat[,"diversity"] <- runmat[,"diversity"] + mat[,"diversity"]
}
runmat[,"mean"] <- runmat[,"mean"]/numislands
runmat[,"diversity"] <- runmat[,"diversity"]/numislands
}
stats[[i]] <- runmat
resbestall[sprintf("run%d",i)] <- runmat[,"best"]
}
resmean <- as.data.frame(statmat(stats, mean))
resse <- as.data.frame(statmat(stats, stderror))
return (list("mean"=resmean, "se"=resse, "all" = resbestall))
}
get_solutions <- function (data) {
numruns <- length(data)
numvar <- length(data[[1]]$rundata[[1]]$isols$genome[[1]])
table_solutions <- data.frame(matrix(ncol=numvar+2, nrow=numruns))
colnames(table_solutions) <- c("evals", "fitness", paste("V", 1:numvar, sep=""))
for (i in 1:numruns) {
rowi <- max(which(data[[i]]$rundata[[1]]$isols$evals < maxevals))
table_solutions[i, "evals"] <- data[[i]]$rundata[[1]]$isols$evals[rowi]
table_solutions[i, "fitness"] <- data[[i]]$rundata[[1]]$isols$fitness[rowi]
for (j in seq(1, numvar)) {
table_solutions[i, j+2] <- data[[i]]$rundata[[1]]$isols$genome[rowi][[1]][j]
}
}
return(table_solutions)
}
num_algorithms <- length(algorithms)
num_instances <- length(instances)
data_list <- list()
i <- 1
for (instance in instances) {
for (alg in algorithms) {
json_data <- fromJSON(file = paste(alg, "-stats-", instance, ".json", sep=""))
data_list[[i]] <- list("rundata" = process_runbatch(json_data),
"sols" = get_solutions(json_data))
i <- i + 1
}
}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
library(rjson)
# general parameters
maxevals <- params$maxevals
instances <- params$instances
algorithms <- params$algorithms
# samples a datafile at regular intervals
sampling <- function (rundata, s, maxevals) {
n = length(rundata$evals)
numsamples <- floor(maxevals/s)
mat <- matrix(nrow=numsamples, ncol=2)
first <- rundata$evals[1]
i<-1
for (j in seq(from = 1, to = numsamples)) {
ev <- j * s;
mat[j,1] <- ev
if (ev < first) {
mat[j,2] <- NA
} else {
while ((i<=n) & (rundata$evals[i] < ev)) {
i <- i + 1
}
if ((i<=n) & (rundata$evals[i] == ev)) {
k <- i
}
else {
k <- i - 1
}
mat[j,2] <- rundata$data[k]
}
}
return (mat)
}
# standard error of the mean
stderror <- function(x) sd(x)/sqrt(length(x))
# reduces a list of matrices to a single matrix using
# some aggregation function
statmat <- function(lst, fnc) {
n <- length(lst)
rc <- dim(lst[[1]])
ar1 <- array(unlist(lst), c(rc, n))
mat <- apply(ar1, c(1, 2), fnc)
colnames(mat)=c("evals", "best", "current", "mean", "diversity")
return(mat)
}
# prepares the results of a single island in a format amenable for further
# processing
process_rundata <- function (rundata) {
s <- 100
df <- data.frame("evals" = rundata$isols$evals, "data" = rundata$isols$fitness)
mat1 <- sampling(df, s, maxevals)
df <- data.frame("evals" = rundata$idata$evals, "data" = rundata$idata$best)
mat2 <- sampling(df, s, maxevals)
mat1 <- cbind(mat1, mat2[,2])
df <- data.frame("evals" = rundata$idata$evals, "data" = rundata$idata$mean)
mat2 <- sampling(df, s, maxevals)
mat1 <- cbind(mat1, mat2[,2])
df <- data.frame("evals" = rundata$idata$evals, "data" = rundata$idata$diversity)
mat2 <- sampling(df, s, maxevals)
mat1 <- cbind(mat1, mat2[,2])
colnames(mat1) <- c("evals", "best", "current", "mean", "diversity")
return (mat1)
}
# processes a batch of data files (one per run)
# computes the mean and standard error of each column
process_runbatch <- function (data) {
stats <- list()
numislands <- length(data[[1]]$rundata)
numruns <- length(data)
for (i in seq(1, numruns)) {
# compute the global EA state at each moment
runmat <- process_rundata(data[[i]]$rundata[[1]])
if (i == 1) {
resbestall <- data.frame("evals" = runmat[,"evals"])
}
if (numislands>1) {
for (j in seq(2, numislands)) {
mat <- process_rundata(data[[i]]$rundata[[j]])
runmat[,"current"] <- pmax(runmat[,"current"], mat[,"current"])
runmat[,"best"] <- pmax(runmat[,"best"], mat[,"best"])
runmat[,"mean"] <- runmat[,"mean"] + mat[,"mean"]
runmat[,"diversity"] <- runmat[,"diversity"] + mat[,"diversity"]
}
runmat[,"mean"] <- runmat[,"mean"]/numislands
runmat[,"diversity"] <- runmat[,"diversity"]/numislands
}
stats[[i]] <- runmat
resbestall[sprintf("run%d",i)] <- runmat[,"best"]
}
resmean <- as.data.frame(statmat(stats, mean))
resse <- as.data.frame(statmat(stats, stderror))
return (list("mean"=resmean, "se"=resse, "all" = resbestall))
}
get_solutions <- function (data) {
numruns <- length(data)
numvar <- length(data[[1]]$rundata[[1]]$isols$genome[[1]])
table_solutions <- data.frame(matrix(ncol=numvar+2, nrow=numruns))
colnames(table_solutions) <- c("evals", "fitness", paste("V", 1:numvar, sep=""))
for (i in 1:numruns) {
rowi <- max(which(data[[i]]$rundata[[1]]$isols$evals < maxevals))
table_solutions[i, "evals"] <- data[[i]]$rundata[[1]]$isols$evals[rowi]
table_solutions[i, "fitness"] <- data[[i]]$rundata[[1]]$isols$fitness[rowi]
for (j in seq(1, numvar)) {
table_solutions[i, j+2] <- data[[i]]$rundata[[1]]$isols$genome[rowi][[1]][j]
}
}
return(table_solutions)
}
num_algorithms <- length(algorithms)
num_instances <- length(instances)
data_list <- list()
i <- 1
for (instance in instances) {
for (alg in algorithms) {
json_data <- fromJSON(file = paste(alg, "-stats-", instance, ".json", sep=""))
data_list[[i]] <- list("rundata" = process_runbatch(json_data),
"sols" = get_solutions(json_data))
i <- i + 1
}
}
